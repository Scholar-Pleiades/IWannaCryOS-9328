#include <Arduino.h>
#include "ILI.h"

#define SWAP_INT(a, b) do { int _t = a; a = b; b = _t; } while (0)


static const unsigned char font[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 0x3E, 0x6B,
    0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x18, 0x3C, 0x7E, 0x3C,
    0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00,
    0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 0x00, 0x18, 0x24,
    0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x30, 0x48, 0x3A, 0x06, 0x0E,
    0x26, 0x29, 0x79, 0x29, 0x26, 0x40, 0x7F, 0x05, 0x05, 0x07, 0x40, 0x7F,
    0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x7F, 0x3E, 0x1C, 0x1C,
    0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x5F,
    0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00, 0x66, 0x89,
    0x95, 0x6A, 0x60, 0x60, 0x60, 0x60, 0x60, 0x94, 0xA2, 0xFF, 0xA2, 0x94,
    0x08, 0x04, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x20, 0x10, 0x08, 0x08,
    0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x1E, 0x10, 0x10, 0x10,
    0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x30, 0x38, 0x3E, 0x38, 0x30, 0x06,
    0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14,
    0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64, 0x62, 0x36, 0x49,
    0x56, 0x20, 0x50, 0x00, 0x08, 0x07, 0x03, 0x00, 0x00, 0x1C, 0x22, 0x41,
    0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x08,
    0x08, 0x3E, 0x08, 0x08, 0x00, 0x80, 0x70, 0x30, 0x00, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02,
    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x72, 0x49,
    0x49, 0x49, 0x46, 0x21, 0x41, 0x49, 0x4D, 0x33, 0x18, 0x14, 0x12, 0x7F,
    0x10, 0x27, 0x45, 0x45, 0x45, 0x39, 0x3C, 0x4A, 0x49, 0x49, 0x31, 0x41,
    0x21, 0x11, 0x09, 0x07, 0x36, 0x49, 0x49, 0x49, 0x36, 0x46, 0x49, 0x49,
    0x29, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00,
    0x00, 0x08, 0x14, 0x22, 0x41, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x41,
    0x22, 0x14, 0x08, 0x02, 0x01, 0x59, 0x09, 0x06, 0x3E, 0x41, 0x5D, 0x59,
    0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E,
    0x41, 0x41, 0x41, 0x22, 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x49, 0x49,
    0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x3E, 0x41, 0x41, 0x51, 0x73,
    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x20, 0x40,
    0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F, 0x40, 0x40, 0x40,
    0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E,
    0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x3E, 0x41, 0x51,
    0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x26, 0x49, 0x49, 0x49, 0x32,
    0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x1F, 0x20,
    0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63, 0x14, 0x08, 0x14,
    0x63, 0x03, 0x04, 0x78, 0x04, 0x03, 0x61, 0x59, 0x49, 0x4D, 0x43, 0x00,
    0x7F, 0x41, 0x41, 0x41, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x41, 0x41,
    0x41, 0x7F, 0x04, 0x02, 0x01, 0x02, 0x04, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x00, 0x03, 0x07, 0x08, 0x00, 0x20, 0x54, 0x54, 0x78, 0x40, 0x7F, 0x28,
    0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38, 0x44, 0x44, 0x28,
    0x7F, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x08, 0x7E, 0x09, 0x02, 0x18,
    0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x44, 0x7D,
    0x40, 0x00, 0x20, 0x40, 0x40, 0x3D, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x7C, 0x08,
    0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC, 0x18, 0x24, 0x24,
    0x18, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x48,
    0x54, 0x54, 0x54, 0x24, 0x04, 0x04, 0x3F, 0x44, 0x24, 0x3C, 0x40, 0x40,
    0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x3C, 0x40, 0x30, 0x40, 0x3C,
    0x44, 0x28, 0x10, 0x28, 0x44, 0x4C, 0x90, 0x90, 0x90, 0x7C, 0x44, 0x64,
    0x54, 0x4C, 0x44, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x77, 0x00,
    0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x02, 0x01, 0x02, 0x04, 0x02, 0x3C,
    0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1, 0xA1, 0x61, 0x12, 0x3A, 0x40, 0x40,
    0x20, 0x7A, 0x38, 0x54, 0x54, 0x55, 0x59, 0x21, 0x55, 0x55, 0x79, 0x41,
    0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
    0x21, 0x55, 0x54, 0x78, 0x40, 0x20, 0x54, 0x55, 0x79, 0x40, 0x0C, 0x1E,
    0x52, 0x72, 0x12, 0x39, 0x55, 0x55, 0x55, 0x59, 0x39, 0x54, 0x54, 0x54,
    0x59, 0x39, 0x55, 0x54, 0x54, 0x58, 0x00, 0x00, 0x45, 0x7C, 0x41, 0x00,
    0x02, 0x45, 0x7D, 0x42, 0x00, 0x01, 0x45, 0x7C, 0x40, 0x7D, 0x12, 0x11,
    0x12, 0x7D, // A-umlaut
    0xF0, 0x28, 0x25, 0x28, 0xF0, 0x7C, 0x54, 0x55, 0x45, 0x00, 0x20, 0x54,
    0x54, 0x7C, 0x54, 0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x32, 0x49, 0x49, 0x49,
    0x32, 0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
    0x32, 0x4A, 0x48, 0x48, 0x30, 0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A, 0x42,
    0x40, 0x20, 0x78, 0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x3D, 0x42, 0x42, 0x42,
    0x3D, // O-umlaut
    0x3D, 0x40, 0x40, 0x40, 0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24, 0x48, 0x7E,
    0x49, 0x43, 0x66, 0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09, 0x29, 0xF6,
    0x20, 0xC0, 0x88, 0x7E, 0x09, 0x03, 0x20, 0x54, 0x54, 0x79, 0x41, 0x00,
    0x00, 0x44, 0x7D, 0x41, 0x30, 0x48, 0x48, 0x4A, 0x32, 0x38, 0x40, 0x40,
    0x22, 0x7A, 0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19, 0x31, 0x7D,
    0x26, 0x29, 0x29, 0x2F, 0x28, 0x26, 0x29, 0x29, 0x29, 0x26, 0x30, 0x48,
    0x4D, 0x40, 0x20, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x38, 0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00,
    0x00, 0x7B, 0x00, 0x00, 0x08, 0x14, 0x2A, 0x14, 0x22, 0x22, 0x14, 0x2A,
    0x14, 0x08, 0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old
                                              // code
    0xAA, 0x55, 0xAA, 0x55, 0xAA,             // 50% block
    0xFF, 0x55, 0xFF, 0x55, 0xFF,             // 75% block
    0x00, 0x00, 0x00, 0xFF, 0x00, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14,
    0x14, 0xFF, 0x00, 0x10, 0x10, 0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10,
    0xF0, 0x14, 0x14, 0x14, 0xFC, 0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00,
    0x00, 0xFF, 0x00, 0xFF, 0x14, 0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17,
    0x10, 0x1F, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00,
    0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10,
    0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00,
    0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F,
    0x10, 0x17, 0x00, 0x00, 0xFC, 0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17,
    0x14, 0x14, 0xF4, 0x04, 0xF4, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17,
    0x14, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10,
    0x10, 0xF0, 0x10, 0xF0, 0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00,
    0x1F, 0x14, 0x00, 0x00, 0x00, 0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0,
    0x10, 0x10, 0xFF, 0x10, 0xFF, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10,
    0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44,
    0x38, 0x44, 0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
    0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E, 0x02, 0x63, 0x55,
    0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40, 0x7E, 0x20, 0x1E,
    0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7, 0xA5, 0x99, 0x1C,
    0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C, 0x30, 0x4A, 0x4D,
    0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62, 0x5A, 0x46, 0x3D,
    0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01, 0x7E, 0x2A, 0x2A,
    0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40, 0x51, 0x4A, 0x44,
    0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF, 0x01, 0x03, 0xE0,
    0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08, 0x36, 0x12, 0x36,
    0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00, 0x18, 0x18, 0x00,
    0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01, 0x01, 0x00, 0x1F,
    0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00, 0x3C, 0x3C, 0x3C,
    0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 // #255 NBSP
};

// ---------- DATA BUS ----------
#define D01_PORT PORTB
#define D01_DDR  DDRB

#define D27_PORT PORTD
#define D27_DDR  DDRD

// ---------- CONTROL BUS ----------
#define CTRL_PORT PORTC
#define CTRL_DDR  DDRC

#define RD  (1 << 0)
#define WR  (1 << 1)
#define RS  (1 << 2)
#define CS  (1 << 3)
#define RST (1 << 4)

#define RD_LOW()   CTRL_PORT &= ~RD
#define RD_HIGH()  CTRL_PORT |=  RD

#define WR_LOW()   CTRL_PORT &= ~WR
#define WR_HIGH()  CTRL_PORT |=  WR

#define RS_CMD()   CTRL_PORT &= ~RS
#define RS_DATA()  CTRL_PORT |=  RS

#define CS_LOW()   CTRL_PORT &= ~CS
#define CS_HIGH()  CTRL_PORT |=  CS

#define RST_LOW()  CTRL_PORT &= ~RST
#define RST_HIGH() CTRL_PORT |=  RST

#define PIXEL_PULSE \
    D01_PORT = hi_B; D27_PORT = hi_D; WR_LOW(); WR_HIGH(); \
    D01_PORT = lo_B; D27_PORT = lo_D; WR_LOW(); WR_HIGH();
// Sends a single 8-bit byte to the data bus

static uint8_t hi_B, hi_D;
static uint8_t lo_B, lo_D;

#define LOAD_COLOR(c)                  \
    hi_B = (c >> 8) & 0x03;            \
    hi_D = (c >> 8) & 0xFC;            \
    lo_B = (c & 0xFF) & 0x03;          \
    lo_D = (c & 0xFF) & 0xFC;


static inline void tftWrite8(uint8_t d) {
    D01_PORT = (D01_PORT & 0xFC) | (d & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (d & 0xFC);
    WR_LOW();
    WR_HIGH();
}

// ILI9328 expects a 16-bit Index (Register Address)
void tftCmd(uint16_t reg) {
    RS_CMD();
    CS_LOW();
    tftWrite8(reg >> 8);   // Send High Byte first 
    tftWrite8(reg & 0xFF); // Send Low Byte
    CS_HIGH();
}

// ILI9328 expects 16-bit Data for the previously selected Register
void tftData(uint16_t data) {
    RS_DATA();
    CS_LOW();
    tftWrite8(data >> 8);   // Send High Byte first [cite: 576]
    tftWrite8(data & 0xFF); // Send Low Byte
    CS_HIGH();
}
void tftInit(void)
{
    // 1. Initialize Bus Directions
    D01_DDR  |= 0x03;   // PB0–1
    D27_DDR  |= 0xFC;   // PD2–7
    CTRL_DDR |= RD | WR | RS | CS | RST;

    // Set control lines high
    CS_HIGH();
    WR_HIGH();
    RD_HIGH();

    // 2. Hardware Reset Sequence
    RST_HIGH();
    delay(5);
    RST_LOW();
    delay(20);
    RST_HIGH();
    delay(50);

    // 3. Start Internal Oscillator
    tftCmd(0x0000); tftData(0x0001); // Start internal osc 
    delay(50);

    // 4. Driver Output & LCD Drive Control
    tftCmd(0x0001); tftData(0x0100); // SS=1 (Source shift direction) 
    tftCmd(0x0002); tftData(0x0700); // LCD Driving Waveform Control
    tftCmd(0x0003); tftData(0x1038); // Entry Mode: BGR=1, ID[1:0]=11 (Increment)
    tftCmd(0x0004); tftData(0x0000); // Resizing Control (Disabled)
    tftCmd(0x0008); tftData(0x0202); // Display Control 2 (BP/FP) [cite: 111]
    tftCmd(0x0009); tftData(0x0000); // Display Control 3
    tftCmd(0x000A); tftData(0x0000); // Display Control 4 (FMARK)
    tftCmd(0x000C); tftData(0x0000); // External Interface Control
    tftCmd(0x000D); tftData(0x0000); // Frame Marker Position
    tftCmd(0x000F); tftData(0x0000); // GDDRAM Interface Control

    // 5. Power Sequence (STRICT ORDER REQUIRED) [cite: 168]
    tftCmd(0x0010); tftData(0x0000); // Power Control 1: Disable SAP
    tftCmd(0x0011); tftData(0x0007); // Power Control 2
    tftCmd(0x0012); tftData(0x0000); // Power Control 3
    tftCmd(0x0013); tftData(0x0000); // Power Control 4
    delay(200);

    tftCmd(0x0010); tftData(0x1790); // BT, AP bits 
    tftCmd(0x0011); tftData(0x0227); // DC0, DC1, VC bits [cite: 166]
    delay(50);
    tftCmd(0x0012); tftData(0x009C); // VRH bits (Reference voltage) [cite: 168]
    delay(50);
    tftCmd(0x0013); tftData(0x1900); // VDV bits
    tftCmd(0x0029); tftData(0x0023); // VCM bits [cite: 186]
    tftCmd(0x002B); tftData(0x000E); // Frame Rate [cite: 227]
    delay(50);

    // 6. Set RAM Area (240x320)
    tftCmd(0x0020); tftData(0x0000); // GRAM Address Set
    tftCmd(0x0021); tftData(0x0000);
    tftCmd(0x0050); tftData(0x0000); // Horizontal Address Start
    tftCmd(0x0051); tftData(0x013F); // Horizontal Address End (239)
    tftCmd(0x0052); tftData(0x0000); // Vertical Address Start
    tftCmd(0x0053); tftData(0x00EF); // Vertical Address End (319)

    // 7. Gamma Settings (Balanced for most panels) [cite: 236]
    tftCmd(0x0030); tftData(0x0007);
    tftCmd(0x0031); tftData(0x0707);
    tftCmd(0x0032); tftData(0x0006);
    tftCmd(0x0035); tftData(0x0704);
    tftCmd(0x0036); tftData(0x1F04);
    tftCmd(0x0037); tftData(0x0004);
    tftCmd(0x0038); tftData(0x0000);
    tftCmd(0x0039); tftData(0x0706);
    tftCmd(0x003C); tftData(0x0701);
    tftCmd(0x003D); tftData(0x000F);

    // 8. Gate Scan Control
    tftCmd(0x0060); tftData(0x2700); // Driver Output Control (GS bit) [cite: 201]
    tftCmd(0x0061); tftData(0x0001); // Base Image Display Control
    tftCmd(0x006A); tftData(0x0000); // Vertical Scroll Control

    // 9. Display ON Sequence
    tftCmd(0x0007); tftData(0x0133); // BASEE=1, GON=1, DTE=1, D[1:0]=11 [cite: 93, 107]
    delay(20);
}
void tftSetWindow(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) {
    // After swapping: x0,x1 are vertical (0-319), y0,y1 are horizontal (0-239)
    tftCmd(0x0050); tftData(y0); // Horizontal Start (now Y)
    tftCmd(0x0051); tftData(y1); // Horizontal End (now Y)
    tftCmd(0x0052); tftData(x0); // Vertical Start (now X)
    tftCmd(0x0053); tftData(x1); // Vertical End (now X)

    tftCmd(0x0020); tftData(y0); // Set GRAM X Address Counter (now Y)
    tftCmd(0x0021); tftData(x0); // Set GRAM Y Address Counter (now X)
    tftCmd(0x0022);              // Prepare to write to GRAM
}
void tftResetWindow(void)
{
    // Horizontal: 0 to 239 (0x00 to 0xEF)
    tftCmd(ILI_H_START); tftData(0x0000);
    tftCmd(ILI_H_END);   tftData(0x013F);

    // Vertical: 0 to 319 (0x00 to 0x13F)
    tftCmd(ILI_V_START); tftData(0x0000);
    tftCmd(ILI_V_END);   tftData(0x00EF);
}

void tftFill(uint16_t color)
{
    tftSetWindow(0, 0, 319, 239);
    // 1. Prepare the controller for GRAM access
    tftCmd(0x0022); 
    RS_DATA();
    CS_LOW();

    // 2. Pre-calculate PORT values (Optimization: Calculate only once)
    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;

    // These represent exactly what the PORTS should look like for hi and lo bytes
    uint8_t hi_B = (D01_PORT & 0xFC) | (hi & 0x03);
    uint8_t hi_D = (D27_PORT & 0x03) | (hi & 0xFC);
    uint8_t lo_B = (D01_PORT & 0xFC) | (lo & 0x03);
    uint8_t lo_D = (D27_PORT & 0x03) | (lo & 0xFC);

    // 3. The Loop (Unrolled for maximum speed)
    // 320 * 240 = 76,800 pixels. 
    // We use a 16-bit counter (faster on AVR) and process 16 pixels per iteration.
    uint16_t n = 4800; 

    while (n--)
    {
        // Macros to blast the 2-byte pixel sequence to the bus
        // This eliminates function call overhead and re-masking
        #define PIX_WRITE \
            D01_PORT = hi_B; D27_PORT = hi_D; WR_LOW(); WR_HIGH(); \
            D01_PORT = lo_B; D27_PORT = lo_D; WR_LOW(); WR_HIGH();

        // Write 16 pixels per loop iteration (unrolling)
        PIX_WRITE; PIX_WRITE; PIX_WRITE; PIX_WRITE;
        PIX_WRITE; PIX_WRITE; PIX_WRITE; PIX_WRITE;
        PIX_WRITE; PIX_WRITE; PIX_WRITE; PIX_WRITE;
        PIX_WRITE; PIX_WRITE; PIX_WRITE; PIX_WRITE;
    }

    CS_HIGH();

    tftResetWindow();
}

void drawPixel(uint16_t x, uint16_t y, uint16_t color) {
    if (x >= 320 || y >= 240) return;

    tftSetWindow(x, y, x, y);
    tftCmd(ILI_RW_GRAM);

    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;

    RS_DATA();
    CS_LOW();

    // High byte
    D01_PORT = (D01_PORT & 0xFC) | (hi & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (hi & 0xFC);
    WR_LOW(); WR_HIGH();

    // Low byte
    D01_PORT = (D01_PORT & 0xFC) | (lo & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (lo & 0xFC);
    WR_LOW(); WR_HIGH();

    CS_HIGH();
}

static inline void writePixel(uint16_t color) {
    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;

    D01_PORT = (D01_PORT & 0xFC) | (hi & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (hi & 0xFC);
    WR_LOW(); WR_HIGH();

    D01_PORT = (D01_PORT & 0xFC) | (lo & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (lo & 0xFC);
    WR_LOW(); WR_HIGH();
}


void drawFastVLine(uint16_t x, uint16_t y, uint16_t h, uint16_t color) {
    if (x >= 320 || y >= 240 || h == 0) return;
    if (y + h > 240) h = 240 - y;

    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;

    tftSetWindow(x, y, x, y + h - 1);
    tftCmd(ILI_RW_GRAM);

    RS_DATA(); CS_LOW();
while (h--) {
    D01_PORT = (D01_PORT & 0xFC) | (hi & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (hi & 0xFC);
    WR_LOW(); WR_HIGH();

    D01_PORT = (D01_PORT & 0xFC) | (lo & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (lo & 0xFC);
    WR_LOW(); WR_HIGH();
}
CS_HIGH();

}

void drawFastHLine(uint16_t x, uint16_t y, uint16_t w, uint16_t color) {
    if (y >= 240 || x >= 320 || w == 0) return;
    if (x + w > 320) w = 320 - x;

    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;

    tftSetWindow(x, y, x + w - 1, y);
    tftCmd(ILI_RW_GRAM);

    RS_DATA(); CS_LOW();
while (w--) {
    D01_PORT = (D01_PORT & 0xFC) | (hi & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (hi & 0xFC);
    WR_LOW(); WR_HIGH();

    D01_PORT = (D01_PORT & 0xFC) | (lo & 0x03);
    D27_PORT = (D27_PORT & 0x03) | (lo & 0xFC);
    WR_LOW(); WR_HIGH();
}
CS_HIGH();

}
void fillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
    if (x >= 320 || y >= 240 || w == 0 || h == 0) return;
    if (x + w > 320) w = 320 - x;
    if (y + h > 240) h = 240 - y;

    uint32_t total = (uint32_t)w * h;
    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;

    tftSetWindow(x, y, x + w - 1, y + h - 1);
    tftCmd(ILI_RW_GRAM);

    RS_DATA();
    CS_LOW();

    while (total--) {
        // inline port writes for speed
        D01_PORT = (D01_PORT & 0xFC) | (hi & 0x03);
        D27_PORT = (D27_PORT & 0x03) | (hi & 0xFC);
        WR_LOW(); WR_HIGH();

        D01_PORT = (D01_PORT & 0xFC) | (lo & 0x03);
        D27_PORT = (D27_PORT & 0x03) | (lo & 0xFC);
        WR_LOW(); WR_HIGH();
    }

    CS_HIGH();
}

void drawLine(int x0, int y0, int x1, int y1, uint16_t color) {
    if (y0 == y1) {
        if (x1 < x0) SWAP_INT(x0, x1);
        drawFastHLine(x0, y0, x1 - x0 + 1, color);
        return;
    }
    if (x0 == x1) {
        if (y1 < y0) SWAP_INT(y0, y1);
        drawFastVLine(x0, y0, y1 - y0 + 1, color);
        return;
    }

    int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int err = dx + dy, e2;

    while (1) {
        drawPixel(x0, y0, color);
        if (x0 == x1 && y0 == y1) break;
        e2 = err << 1;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
    }
}

void drawRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
    drawFastHLine(x, y, w, color);
    drawFastHLine(x, y + h - 1, w, color);
    drawFastVLine(x, y, h, color);
    drawFastVLine(x + w - 1, y, h, color);
}

// ---------- TEXT FUNCTIONS (MAX SPEED) ----------
TFT_State cursor = {0, 0, WHITE, BLACK, 1, true};

// for max speed
void setCursor(uint16_t x, uint16_t y) {
    cursor.x = x;
    cursor.y = y;
}

void setTextColor(uint16_t c, uint16_t b) {
    cursor.textColor = c;
    cursor.bgColor = b;
}

void setTextColor(uint16_t c) {
    cursor.textColor = c;
    cursor.bgColor = BLACK;
}

void setTextSize(uint8_t s) {
    cursor.textSize = s ? s : 1;
}

void setTextWrap(bool w) {
    cursor.wrap = w;
}
void drawChar(uint16_t x, uint16_t y, char c,
              uint16_t color, uint16_t bg, uint8_t size)
{
    if (x >= 320 || y >= 240) return;

    uint16_t idx = (uint8_t)c * 5;

    // -------- FAST PATH: size == 1 --------
    if (size == 1) {
        for (uint8_t i = 0; i < 5; i++) {
            uint8_t col = pgm_read_byte(&font[idx++]);

            // Proper window + cursor setup
            tftSetWindow(x + i, y, x + i, y + 6);
            tftCmd(ILI_RW_GRAM);

            RS_DATA();
            CS_LOW();

            // 7 vertical pixels
            for (uint8_t b = 0; b < 7; b++) {
                if (col & (1 << b)) {
                    LOAD_COLOR(color);
                } else if (bg != color) {
                    LOAD_COLOR(bg);
                } else {
                    continue;
                }
                PIXEL_PULSE
            }

            CS_HIGH();
        }

        // Spacing column
        if (bg != color) {
            tftSetWindow(x + 5, y, x + 5, y + 6);
            tftCmd(ILI_RW_GRAM);

            RS_DATA();
            CS_LOW();

            LOAD_COLOR(bg);
            for (uint8_t i = 0; i < 7; i++) {
                PIXEL_PULSE
            }

            CS_HIGH();
        }
        return;
    }

    // -------- SCALED PATH (size > 1) --------
    uint16_t w = 5 * size;
    uint16_t h = 7 * size;

    if (bg != color) {
        fillRect(x, y, w + size, h, bg);
    }

    for (uint8_t i = 0; i < 5; i++) {
        uint8_t col = pgm_read_byte(&font[idx++]);
        uint16_t px = x + i * size;

        if (col & 0x01) fillRect(px, y + 0 * size, size, size, color);
        if (col & 0x02) fillRect(px, y + 1 * size, size, size, color);
        if (col & 0x04) fillRect(px, y + 2 * size, size, size, color);
        if (col & 0x08) fillRect(px, y + 3 * size, size, size, color);
        if (col & 0x10) fillRect(px, y + 4 * size, size, size, color);
        if (col & 0x20) fillRect(px, y + 5 * size, size, size, color);
        if (col & 0x40) fillRect(px, y + 6 * size, size, size, color);
    }
}

// ULTRA-FAST string printing - minimal overhead
void tftPrint(const char* str) {
    uint16_t start_x = cursor.x;
    uint16_t start_y = cursor.y;
    uint8_t char_width = 6 * cursor.textSize;
    
    while (*str) {
        // Fast path for printable characters
        if (*str >= 32 && *str <= 126) {
            // Wrap check (minimal branching)
            if (cursor.wrap && (cursor.x + char_width) > 320) {
                cursor.x = 0;
                cursor.y += 7 * cursor.textSize;
                
                // Screen bounds check
                if (cursor.y >= 240) {
                    cursor.y = start_y; // Reset to start for stability
                }
            }
            
            // Draw character directly without function call overhead
            drawChar(cursor.x, cursor.y, *str, cursor.textColor, cursor.bgColor, cursor.textSize);
            
            // Move cursor (pre-calculated width)
            cursor.x += char_width + (cursor.textSize > 1 ? 1 : 0);
        }
        // Handle control characters
        else {
            switch (*str) {
                case '\n':
                    cursor.x = 0;
                    cursor.y += 7 * cursor.textSize;
                    if (cursor.y >= 240) cursor.y = 0;
                    break;
                case '\r':
                    cursor.x = 0;
                    break;
                case '\t':
                    cursor.x = (cursor.x + 4 * char_width) & ~(char_width - 1);
                    if (cursor.x >= 320) cursor.x = 0;
                    break;
            }
        }
        str++;
    }
}

// Optimized single-line print
void tftPrintln(const char* str) {
    tftPrint(str);
    cursor.x = 0;
    cursor.y += 7 * cursor.textSize;
    if (cursor.y >= 240) cursor.y = 0;
}

// Direct number printing without float/double
void tftPrintInt(int32_t n) {
    char buf[12];
    char *ptr = buf + 11;
    *ptr = '\0';
    
    int32_t neg = n < 0;
    if (neg) n = -n;
    
    do {
        *--ptr = '0' + (n % 10);
        n /= 10;
    } while (n);
    
    if (neg) *--ptr = '-';
    
    tftPrint(ptr);
}

void tftPrintUInt(uint32_t n) {
    char buf[11];
    char *ptr = buf + 10;
    *ptr = '\0';
    
    do {
        *--ptr = '0' + (n % 10);
        n /= 10;
    } while (n);
    
    tftPrint(ptr);
}

// Fast fixed-point decimal (2 decimal places)
void tftPrintFixed(uint32_t value, uint8_t decimals) {
    if (decimals == 0) {
        tftPrintUInt(value);
        return;
    }
    
    uint32_t divisor = 1;
    for (uint8_t i = 0; i < decimals; i++) divisor *= 10;
    
    tftPrintUInt(value / divisor);
    tftPrint(".");
    
    uint32_t fraction = value % divisor;
    for (uint8_t i = 0; i < decimals; i++) {
        divisor /= 10;
        tftPrintChar('0' + (fraction / divisor));
        fraction %= divisor;
    }
}

// Direct single character print (fastest)
void tftPrintChar(char c) {
    if (cursor.wrap && (cursor.x + 6 * cursor.textSize) > 320) {
        cursor.x = 0;
        cursor.y += 7 * cursor.textSize;
        if (cursor.y >= 240) cursor.y = 0;
    }
    
    drawChar(cursor.x, cursor.y, c, cursor.textColor, cursor.bgColor, cursor.textSize);
    cursor.x += 6 * cursor.textSize + (cursor.textSize > 1 ? 1 : 0);
}

// Get current cursor position
uint16_t getCursorX(void) { return cursor.x; }
uint16_t getCursorY(void) { return cursor.y; }

// Clear from cursor to end of line
void clearToEOL(void) {
    if (cursor.x >= 320) return;
    fillRect(cursor.x, cursor.y, 320 - cursor.x, 7 * cursor.textSize, cursor.bgColor);
}

// Clear entire line
void clearLine(void) {
    fillRect(0, cursor.y, 320, 7 * cursor.textSize, cursor.bgColor);
}
